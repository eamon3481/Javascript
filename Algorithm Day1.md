# **Algorithm Day1** 



## [미션1] 분산 처리 (BOJ1009번)



[문제링크]: https://www.acmicpc.net/problem/1009



## 문제



재용이는 최신 컴퓨터 10대를 가지고 있다. 어느 날 재용이는 많은 데이터를 처리해야 될 일이 생겨서 각 컴퓨터에 1번부터 10번까지의 번호를 부여하고, 10대의 컴퓨터가 다음과 같은 방법으로 데이터들을 처리하기로 하였다.

1번 데이터는 1번 컴퓨터, 2번 데이터는 2번 컴퓨터, 3번 데이터는 3번 컴퓨터, ... ,

10번 데이터는 10번 컴퓨터, 11번 데이터는 1번 컴퓨터, 12번 데이터는 2번 컴퓨터, ...

총 데이터의 개수는 항상 a**b개의 형태로 주어진다. 재용이는 문득 마지막 데이터가 처리될 컴퓨터의 번호가 궁금해졌다. 이를 수행해주는 프로그램을 작성하라.



## 입력

입력의 첫 줄에는 테스트 케이스의 개수 T가 주어진다. 그 다음 줄부터 각각의 테스트 케이스에 대해 정수 a와 b가 주어진다. (1 ≤ a < 100, 1 ≤ b < 1,000,000)



## 출력

각 테스트 케이스에 대해 마지막 데이터가 처리되는 컴퓨터의 번호를 출력한다.



## 예제 입력 1 

```
5
1 6
3 7
6 2
7 100
9 635
```



## 예제 출력 1 

```
1
7
6
1
9
```

## 풀이

이 문제는 데이터의 개수를 a**b로 계산해서 %10 으로 나눈 나머지의 값을 계산하는 방법으로 하면 안된다. 

왜냐하면, 마지막 테스트 케이스인 [9, 635]를 넣었을 때, 데이터의 갯수는 9**635 가 되고 nodeJS 상에서는 overflow가 발생하여서 Infinity가 출력되게 된다. 

그렇다면, 이 문제를 어떻게 해결해야 할까?

~~너무나도 고맙게도~~ 10대의 컴퓨터가 있기 때문에 데이터의 총 갯수의 맨 끝자리 수가 결국엔 마지막으로 처리될 컴퓨터의 번호가 될 것입니다. (물론, 마지막 자리수가 0일때는 10번째 컴퓨터를 뜻하는 것이겠지요.)

예를 들면,   [3, 7] 이라는 입력 예시를 보면, 3**7 = 2187 개의 데이터가 존재하고 10개의 컴퓨터에 차례대로 넣다보면 나머지는 7개가 남고 7번째 컴퓨터에 마지막으로 저장되게 되는 겁니다. 



여기까지 생각했으면 거의 다했습니다. 

우리는 a 에 몇 제곱을 하든지 1의 자리에만 관심있기 때문에 a를 10으로 나눈 나머지인 a%10을 구하고,  그 값에 또 a를 곱한 값에 %10 을 나눠주어서 나머지를 구하는 작업을 반복할 것입니다.  이 작업을 한 번 하면 b = 1 일 때 이며, 두 번 하면 b = 2 일때 ,  n 번 하면 b = n 일 때 입니다. 



## 더 생각해 볼것

컴퓨터의 갯수가 10개가 아니라 8개였다면 어떤식으로 풀어야할까요?

주어진 숫자를 8진법으로 바꾸고 진행 해봐야 할 것 같지만 막상 생각해봐도 어려울 것 같습니다. 

제곱또한 생각해야해서 어려울 것 같네요. 





## [미션2] 저항  (BOJ1076번)



[문제링크]: https://www.acmicpc.net/problem/1076



## 문제

전자 제품에는 저항이 들어간다. 저항은 색 3개를 이용해서 그 저항이 몇 옴인지 나타낸다.

처음 색 2개는 저항의 값이고, 마지막 색은 곱해야 하는 값이다.

저항의 값은 다음 표를 이용해서 구한다.

| 색     | 값   | 곱         |
| :----- | :--- | :--------- |
| black  | 0    | 1          |
| brown  | 1    | 10         |
| red    | 2    | 100        |
| orange | 3    | 1000       |
| yellow | 4    | 10000      |
| green  | 5    | 100000     |
| blue   | 6    | 1000000    |
| violet | 7    | 10000000   |
| grey   | 8    | 100000000  |
| white  | 9    | 1000000000 |

예를 들어, 저항에 색이 yellow, violet, red였다면 저항의 값은 4,700이 된다.



## 입력

첫째 줄에 첫 번째 색, 둘째 줄에 두 번째 색, 셋째 줄에 세 번째 색이 주어진다. 색은 모두 위의 표에 쓰여 있는 색만 주어진다.



## 출력

입력으로 주어진 저항의 저항값을 계산하여 첫째 줄에 출력한다.





## 풀이



이 문제는 좀 쉽게 풀었다. 표에 나온 색들을 배열로 정리했다. (크기가 9인 배열이 된다.)

입력으로는 세개의 String으로 된 배열 하나를 받는데,  array.findindex(function()) 을 이용하여 배열에 있는 색과 일치하는 index numder를 찾아서 값과 곱을 만들어서 계산하였다. 



## 더생각해볼 것

array.findindex() 이 안에 함수만 들어가는 이유를 생각해보자. 

콜백과 연관있는 듯하다. 







## [미션3] 물병 (BOJ1052번)



[문제 링크 ]: https://www.acmicpc.net/problem/1052



## 문제

지민이는 N개의 물병을 가지고 있다. 각 물병에는 물을 무한대로 부을 수 있다. 처음에 모든 물병에는 물이 1리터씩 들어있다. 지민이는 이 물병을 또 다른 장소로 옮기려고 한다. 지민이는 한 번에 K개의 물병을 옮길 수 있다. 하지만, 지민이는 물을 낭비하기는 싫고, 이동을 한 번보다 많이 하기는 싫다. 따라서, 지민이는 물병의 물을 적절히 재분배해서, K개를 넘지 않는 비어있지 않은 물병을 만들려고 한다.

물은 다음과 같이 재분배 한다.

> 먼저 같은 양의 물이 들어있는 물병 두 개를 고른다. 그 다음에 한 개의 물병에 다른 한 쪽에 있는 물을 모두 붓는다. 이 방법을 필요한 만큼 계속 한다.

이런 제약 때문에, N개로 K개를 넘지않는 비어있지 않은 물병을 만드는 것이 불가능할 수도 있다. 다행히도, 새로운 물병을 살 수 있다. 상점에서 사는 물병은 물이 1리터 들어있다.

예를 들어, N=3이고, K=1일 때를 보면, 물병 3개로 1개를 만드는 것이 불가능하다. 한 병을 또다른 병에 부으면, 2리터가 들어있는 물병 하나와, 1리터가 들어있는 물병 하나가 남는다. 만약 상점에서 한 개의 물병을 산다면, 2리터가 들어있는 물병 두 개를 만들 수 있고, 마지막으로 4리터가 들어있는 물병 한 개를 만들 수 있다.



## 입력

첫째 줄에 N과 K가 주어진다. N은 107보다 작거나 같은 자연수이고, K는 1,000보다 작거나 같은 자연수이다.



## 출력

첫째 줄에 상점에서 사야하는 물병의 최솟값을 출력한다. 만약 정답이 없을 경우에는 -1을 출력한다.



## 풀이

이런 문제를 접했을 때, 가장 먼저 해야하는 것은  __N=1, 2, 3, 4 ...  해보면서 문제의 규칙성을 찾는 것이다.__

|   N   | W(물병) |
| :---: | :-----: |
|   2   |    1    |
|   3   |    2    |
|   4   |    1    |
|   5   |    2    |
|   6   |    2    |
|   7   |    3    |
|   8   |    1    |
|   9   |    2    |
|  10   |    2    |



2의 n 제곱일 때, 물병은 하나로 합쳐진다는 것을 알 수 있다. 